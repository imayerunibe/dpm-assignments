---
title: "Examining the relationship between the big-5 personality facets and implicit racial attitudes"
subtitle: "Data processing"
author: "Template: Ian Hussey; content: Isabel Mayer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}

knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE)

```

# Dependencies

```{r}

library(tidyverse)
library(janitor)
library(stringr)
library(openxlsx)
library(sjPlot)

```

# Get data

```{r}

# demographics
data_demographics_raw <- read_csv("../data/raw/data_raw_demographics.csv") |>
  janitor::clean_names()

# bfi data
data_bfi_raw <- read_csv("../data/raw/data_raw_bfi.csv") |>
  janitor::clean_names()

# IAT data
data_iat_raw <- read_csv("../data/raw/data_raw_iat.csv") |>
  janitor::clean_names()

```

# Demographics
Exclusion of age and gender from demographics data.
```{r}
data_age_gender_formatted <- data_demographics_raw %>%
  mutate(
    unique_id = as.character(unique_id),
    response = ifelse(response == "NULL", NA_character_, response)
  ) %>%
  filter(variable %in% c('age', 'sex')) %>%
  filter(!is.na(unique_id)) %>%
  pivot_wider(names_from = variable, values_from = response) %>%
  rename(id = unique_id)
```

# Inversion
Reverse scoring the negatively worded items: the extroversion scale items 2, 5 and 7, conscientiousness items 2, 4, 5 and 9, neuroticism items 2, 5, and 7, agreeableness 1, 3, 6, and 8, and openness items 7 and 9.
```{r}
# Reverse scoring inversed items
data_bfi_reversed <- data_bfi_raw %>%
  mutate(
    # Extroversion (E) scale
    bfi_e2 = 7 - bfi_e2,
    bfi_e5 = 7 - bfi_e5,
    bfi_e7 = 7 - bfi_e7,

    # Conscientiousness (C) scale
    bfi_c2 = 7 - bfi_c2,
    bfi_c4 = 7 - bfi_c4,
    bfi_c5 = 7 - bfi_c5,
    bfi_c9 = 7 - bfi_c9,

    # Neuroticism (N) scale
    bfi_n2 = 7 - bfi_n2,
    bfi_n5 = 7 - bfi_n5,
    bfi_n7 = 7 - bfi_n7,

    # Agreeableness (A) scale
    bfi_a1 = 7 - bfi_a1,
    bfi_a3 = 7 - bfi_a3,
    bfi_a6 = 7 - bfi_a6,
    bfi_a8 = 7 - bfi_a8,

    # Openness (O) scale
    bfi_o7 = 7 - bfi_o7,
    bfi_o9 = 7 - bfi_o9
  )

```

## Sanity Check
Check that all correlations are positive.
```{r}
## Sanity Check
# List of subscales
subscales <- list(
  extroversion = c("bfi_e1", "bfi_e2", "bfi_e3", "bfi_e4", "bfi_e5", "bfi_e6", "bfi_e7", "bfi_e8"),
  conscientiousness = c("bfi_c1", "bfi_c2", "bfi_c3", "bfi_c4", "bfi_c5", "bfi_c6", "bfi_c7", "bfi_c8", "bfi_c9"),
  neuroticism =  c("bfi_n1", "bfi_n2", "bfi_n3", "bfi_n4", "bfi_n5", "bfi_n6", "bfi_n7", "bfi_n8"),
  agreeableness = c("bfi_a1", "bfi_a2", "bfi_a3", "bfi_a4", "bfi_a5", "bfi_a6", "bfi_a7", "bfi_a8", "bfi_a9"),
  openness = c("bfi_o1", "bfi_o2", "bfi_o3", "bfi_o4", "bfi_o5", "bfi_o6", "bfi_o7", "bfi_o8", "bfi_o9", "bfi_o10")
)

# Perform the sanity check
sanity_check <- lapply(subscales, function(subscale_items) {
  correlation_matrix <- cor(data_bfi_reversed[subscale_items], use = "complete.obs")
  
  # Print the correlation matrix
  cat("Correlation Matrix for Subscales:", names(subscale_items), "\n")
  print(correlation_matrix)
  
  # Identify negative correlations
  neg_correlations <- correlation_matrix[correlation_matrix < 0]
  cat("Negative Correlations for Subscales:", names(subscale_items), "\n")
  print(neg_correlations)
})

sanity_check
```


# BFI
## Exclusions
### Exclusion by Invalidity of Scores
Adding an exclusion variable for all participants with values outside of the possible range (1-6)
```{r}
## Formatting the data
data_bfi_formatted <- data_bfi_reversed |>
  rename(id = unique_id) |>
  mutate(id = as.character(id))

## Score validity 
# Defining the range for valid scores
valid_score_range <- 1:6

# Creating an exclusion variable for values outside the possible range
data_bfi_exclusion_score <- data_bfi_formatted %>%
  mutate(
    exclusion_bfi_score = ifelse(
      rowSums(across(starts_with("bfi_"), ~ !between(., min(valid_score_range), max(valid_score_range)) & !is.na(.))) > 0,
      "exclude",
      "include"
    )
  ) %>%
  select(id, exclusion_bfi_score) 

# Creating a table of excluded participants
list_exclusion_bfi_score <- data_bfi_exclusion_score %>%
  filter(exclusion_bfi_score == "exclude") %>%
  select(id)

# Printing the table
print(list_exclusion_bfi_score)
```

### Exclusion by Completeness of Data
Creating an exclusion variable for incomplete data within subscales.
```{r}
## Incomplete data
# Defining BFI Scales
bfi_scales <- c("bfi_a", "bfi_c", "bfi_e", "bfi_n", "bfi_o")

# Counting Completed Items within Each Scale
data_bfi_counts <- data_bfi_formatted %>%
  gather(key = "variable", value = "response", starts_with(bfi_scales)) %>%
  group_by(id, variable) %>%
  summarise(
    num_completed_items = sum(!is.na(response)),
    num_items = n()
  )

# Checking for Incomplete Scales
data_bfi_exclusion_incomplete <- data_bfi_counts %>%
  group_by(id) %>%
  summarise(
    exclusion_bfi_completion = ifelse(any(num_completed_items < num_items & num_completed_items > 0), "exclude", "include")
  ) 

# Creating a table of excluded participants
list_exclusion_bfi_completion <- data_bfi_exclusion_incomplete %>%
  filter(exclusion_bfi_completion == "exclude") %>%
  select(id)

# Printing the table
print(list_exclusion_bfi_completion)
```

### Combine Exclusion Variables
Combining both exclusion variables into one.
```{r}
# Combining Exclusion Variables
data_bfi_exclusions <- left_join(data_bfi_exclusion_incomplete, data_bfi_exclusion_score, by = "id") 
```

## Mean Score
Calculating mean scores for each subscale.
```{r}
data_bfi_means <- data_bfi_formatted %>%
  group_by(id) %>%
  summarise(
    mean_agreeableness = mean(c_across(starts_with("bfi_a")), na.rm = TRUE),
    mean_conscientiousness = mean(c_across(starts_with("bfi_c")), na.rm = TRUE),
    mean_extraversion = mean(c_across(starts_with("bfi_e")), na.rm = TRUE),
    mean_neuroticism = mean(c_across(starts_with("bfi_n")), na.rm = TRUE),
    mean_openness = mean(c_across(starts_with("bfi_o")), na.rm = TRUE)
  ) 

# Inserting mean scores in the original data
data_bfi_final <- merge(data_bfi_formatted, data_bfi_means)

# Combining exclusion variables with the final data
data_bfi_final <- merge(data_bfi_final, data_bfi_exclusions, by = "id") |>
  mutate(id = as.character(id)) 
```

### Check for Violators
Checking if all mean scores are within the possible range.
```{r}
# Defining the possible range for each subscale
valid_range <- list(
  bfi_a = c(1, 6),  
  bfi_c = c(1, 6),
  bfi_e = c(1, 6),
  bfi_n = c(1, 6),
  bfi_o = c(1, 6)
)

# Gathering the data for better manipulation
data_bfi_long <- data_bfi_means %>%
  gather(key = "subscale", value = "score", -id)

# Function to check if a value violates the valid range
check_violation <- function(value, subscale) {
  range_limits <- valid_range[[subscale]]
  if (!is.null(range_limits)) {
    between(value, range_limits[1], range_limits[2])
  } else {
    TRUE  # Assume no violation for NULL range_limits
  }
}

# Checking for violations
data_bfi_long <- data_bfi_long %>%
  mutate(violation = ifelse(!pmap_lgl(list(score, subscale), check_violation), "exclude", "include"))

# Spreading the data back to the original format
data_bfi_means_violation <- data_bfi_long %>%
  spread(key = "subscale", value = "score")

# Printing the excluded participants
excluded_participants <- data_bfi_means_violation %>%
  filter(violation == "exclude") %>%
  select(id)

# Creating a table with excluded participants
kable(
  excluded_participants,
  caption = "Excluded Participants",
  format = "html"  
)
```


# IAT


## Formatting

```{r}
# Using the first row as column headers with underscores
col_names <- tolower(gsub(" ", "_", data_iat_raw[1, ]))
colnames(data_iat_raw) <- col_names

# Renaming the columns 
data_iat_formatted <- data_iat_raw %>%
  rename(trial_reaction_time = `trial_reaction_time_(in_ms)`) |>
  rename(id = "unique_id")

# Removing the first row and filtering out practice blocks (blocks 1, 2, and 5)
data_iat_formatted <- data_iat_formatted[-1, ] %>%
  filter(block_number %in% c(3, 4, 6, 7))

# Converting 'trial_reaction_time' to numeric
data_iat_formatted$trial_reaction_time <- as.numeric(data_iat_formatted$trial_reaction_time)
```


## Mean Score
Calculating mean RT for block 3 and 6 (mean1) and for block 4 and 7 (mean2).
```{r}
# Calculating mean scores
iat_mean1 <- data_iat_formatted %>%
  filter(block_number %in% c(3, 6)) %>%
  summarise(iat_mean1 = mean(`trial_reaction_time`, na.rm = TRUE)) %>%
  pull(iat_mean1)

iat_mean2 <- data_iat_formatted %>%
  filter(block_number %in% c(4, 7)) %>%
  summarise(iat_mean2 = mean(`trial_reaction_time`, na.rm = TRUE)) %>%
  pull(iat_mean2)

# Calculating SD of RTs in blocks 3, 4, 6, and 7 (SD)
iat_sd <- data_iat_formatted %>%
  group_by(id) |>
  summarise(iat_SD = sd(`trial_reaction_time`, na.rm = TRUE)) %>%
  pull(iat_SD)

# Calculating mean1, mean2 and SD and adding them to the dataframe
data_iat_formatted <- data_iat_formatted |>
  group_by(id) %>%
  mutate(iat_mean1 = mean(ifelse(block_number %in% c(3, 6), trial_reaction_time, NA), na.rm = TRUE)) |>
  # creates mean 1 (block 3 and 6)
  mutate(iat_mean2 = mean(ifelse(block_number %in% c(4, 7), trial_reaction_time, NA), na.rm = TRUE)) |>
  # creates mean 2 (block 4 and 7)
  mutate(iat_sd = sd(ifelse(block_number %in% c(3, 4, 6, 7), trial_reaction_time, NA), na.rm = TRUE))
  # creates SD (block 3, 4, 6 and 7)
```


## D Score
Scoring the trial-level IAT data using the Greenwald "D" score. Only critical test blocks 3, 4, 6 and 7 are considered.
```{r}
# Adding the D scores to the dataframe
data_iat_formatted <- data_iat_formatted %>%
  group_by(id) %>%
  mutate(iat_D_score = (iat_mean2 - iat_mean1) / iat_sd)
```

### Sanity Check

```{r}
# Sanity check
## Checking if any D score is outside the range [-2, 2]
if (any(data_iat_formatted$iat_D_score < -2 | data_iat_formatted$iat_D_score > 2)) {
  warning("Some D scores are outside the expected range of -2 to +2. Check your implementation.")
} else {
  print("All D scores are within the expected range.")
}

# Create a final dataset with one row per participant
data_iat_final <- data_iat_formatted |>
  select(id, iat_mean1, iat_mean2, iat_sd, iat_D_score) |>
  group_by(id) |>
  distinct(id, .keep_all = TRUE) # Keeps only the first row from each participant
```


## Exclusions
### Exclusion by incomplete data
Excluding participants with less than 120 trials within the critical test blocks 3, 4, 6 and 7.
```{r}
# Number of trials
## Counting the number of trials for each participant
trials_per_participant <- data_iat_formatted %>%
  group_by(id) %>%
  summarise(num_trials = n())

## Setting the exclusion variable based on the number of trials
threshold_trials <- 120
data_iat_exclusion_completion <- data_iat_formatted %>%
  left_join(trials_per_participant, by = "id") %>%
  mutate(exclusion_iat_completion = ifelse(is.na(num_trials) | num_trials < threshold_trials | num_trials > threshold_trials, "exclude", "include")) %>%
  select(-num_trials) |>
  distinct(id, .keep_all = TRUE) |>
  select(id, exclusion_iat_completion)

# Creating a table of excluded participants
list_exclusion_iat_completion <- data_iat_exclusion_completion %>%
  filter(exclusion_iat_completion == "exclude") %>%
  select(id)

# Printing the table
print(list_exclusion_iat_completion)
```

### Exclusion by performance of trials
Excluding participants with >10% of the participants trials are < 300ms, or if their accuracy is < than 75%.
```{r}
# AIT performance
## Setting the exclusion variable based on IAT performance criteria
criteria_threshold_rt <- 300
criteria_threshold_accuracy <- 75

data_iat_exclusion_performance <- data_iat_formatted %>%
  filter(block_number %in% c(3, 4, 6, 7)) %>%
  group_by(id) %>%
  summarise(
    percentage_low_rt = mean(trial_reaction_time < criteria_threshold_rt, na.rm = TRUE) * 100,
    percentage_accuracy = mean(trial_accuracy == "correct", na.rm = TRUE) * 100
  ) %>%
  mutate(
    exclusion_iat_performance = ifelse(
      percentage_low_rt > 10 | percentage_accuracy < 75,
      "exclude",
      "include"
    )) |>
  select(id, exclusion_iat_performance)

# Creating a table of excluded participants
list_exclusion_iat_performance <- data_iat_exclusion_performance %>%
  filter(exclusion_iat_performance == "exclude") %>%
  select(id)

# Printing the table
print(list_exclusion_iat_performance)

```

### Combine Exclusions
Combining the exclusion variables for IAT data into one.
```{r}
# Combining the Exclusion Variables
data_iat_exclusions <- left_join(data_iat_exclusion_completion, data_iat_exclusion_performance, by = "id") |>
  mutate(id = as.character(id))

# Adding Exclusion Variables to the final dataframe
data_iat_final <- merge(data_iat_final, data_iat_exclusions, by = "id") 
```

# Combine Datasets
Combining the demographics, BFI and IAT datasets.
```{r}
# Defining common participants within demographics, BFI and IAT datasets
common_participants <- Reduce(intersect, list(data_age_gender_formatted$id, data_bfi_final$id, data_iat_final$id))

demographics_subset <- data_age_gender_formatted[data_age_gender_formatted$id %in% common_participants, ]
bfi_subset <- data_bfi_final[data_bfi_final$id %in% common_participants, ]
iat_subset <- data_iat_final[data_iat_final$id %in% common_participants, ]

# Merge dataframes using common_participants
merged_data <- inner_join(demographics_subset, bfi_subset, by = "id")
merged_data <- inner_join(merged_data, iat_subset, by = "id")
```

# Master Exclusion
Creating a Master Exclusion variable for all exclusion criteria.
```{r}
# Creating a new dataframa with a Master Exclusion Variable

data_processed <- merged_data %>%
  mutate(
    exclude_participant = case_when(
      exclusion_bfi_completion == "exclude" |
      exclusion_bfi_score == "exclude" |
      exclusion_iat_performance == "exclude" |
        exclusion_iat_completion == "exclude"
      ~ "exclude" ,
      TRUE ~"include"))
```

# Save data

```{r}
write_csv(data_processed, "../data/processed/data_processed.csv")
```

# Code Book
Code book with all variables of the processed data.
I used a different package than we used in class, because I found it quite useful.
```{r}
# Creating a codebook for the processed data file

# do not run again to not overwrite

# library(dataMaid)
# makeCodebook(data_processed) 

```


